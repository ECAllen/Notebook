<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>golang</title>
</head><body><br/>
func ( argname type ) return type { ... }<br/>
<br/>
Ch10 Structs and Methods<br/>
<br/>
Struct<br/>
<br/>
type indentifier struct {<br/>
&nbsp; &nbsp;field1 type<br/>
&nbsp; &nbsp;field2 type <br/>
...<br/>
}<br/>
<br/>
<i>selector:</i>&nbsp;structName.fieldName = value<br/>
<br/>
type T struct { ...<br/>
var s T<br/>
s.a = 5<br/>
s.b = 8<br/>
<br/>
new - allocates memeory for a struct, returns pointer to allocated storage<br/>
var t *T = new(T)<br/>
<br/>
example:<br/>
<br/>
type struct1 struct {<ul><li style="list-style-type: none">i1 int</li>
<li style="list-style-type: none">f1 float32</li>
<li style="list-style-type: none">str string</li>
</ul>
}<br/>
<br/>
func main() {<ul><li style="list-style-type: none">ms := new(struct1)</li>
<li style="list-style-type: none">ms.i1 = 10</li>
<li style="list-style-type: none">ms.f1 = 15.5</li>
<li style="list-style-type: none">ms.str = "blah"</li>
</ul>
...<br/>
<br/>
<i>struct literal: <br/>
</i>ms := &amp;struct1{10, 15.5, "blah"}<br/>
or<br/>
var mt struct1<br/>
mt = struct{ 10, 15.5, "blah" }<br/>
<br/>
equivalent expressions: new(Type) and &amp;Type{}<br/>
<br/>
<i>struct factory:<br/>
<br/>
</i>type File struct {<ul><li style="list-style-type: none">fd int</li>
<li style="list-style-type: none">name string</li>
</ul>
}<br/>
<br/>
func NewFile(fd int, name string) *File {<ul><li style="list-style-type: none">if fd &lt; 0 {</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">return nil</li>
</ul>
</li>
<li style="list-style-type: none">}</li>
<li style="list-style-type: none">return &amp;File{fd, name}</li>
</ul>
}<br/>
<br/>
Nested structs name conflicts:<br/>
1) outer names hide inner names<br/>
2) names at same level are an error if the name is used in the program, ambiguity must be fixed<br/>
<br/>
<i>reciever</i>&nbsp;- function(method?) that acts on a variable of a certain type, cannot be an interface<br/>
<br/>
syntax of a method:<br/>
<b>func</b>&nbsp;(recv receiver_type) methodName(parameter_list) (return_value_list) { ...<br/>
}<br/>
if "recv" is the reciever instance and "Method1" the method name, then: recv.Method1<br/>
* if "recv" is a pointer then it is automatically dreferenced<br/>
<br/>
difference between a function and a method<br/>
a function has the variabe as a parameter: Function1(recv)<br/>
a method is called on the variable: recv.Method1()<br/>
<br/>
<i>base type</i>&nbsp;- the reciever type<br/>
<br/>
Ch 11 Interfaces and reflection<br/>
<br/>
Go's version of polymorphism<br/>
<br/>
Interface syntax:<br/>
type Namer interface {<ul><li style="list-style-type: none">Method1(param_list) return_type</li>
<li style="list-style-type: none">Method2(param_list) return_type</li>
<li style="list-style-type: none">...</li>
</ul>
}<br/>
where Namer is a interface type, name of interface is method name plus the "[e]r" suffix or "able"<br/>
<br/>
example<br/>
<br/>
type Shaper interface {<ul><li style="list-style-type: none">Area() float32</li>
</ul>
}<br/>
<br/>
type Square struct {<ul><li style="list-style-type: none">side float32</li>
</ul>
}<br/>
<br/>
type Rectangle struct {<ul><li style="list-style-type: none">length, width float</li>
</ul>
}<br/>
<br/>
func (sq *Square) Area() float32 {<ul><li style="list-style-type: none">return sq.side * sq.side</li>
</ul>
}<br/>
<br/>
func (r Rectangle) Area() float32 {<ul><li style="list-style-type: none">return r.length * r.width</li>
</ul>
}<br/>
<br/>
func main() {<ul><li style="list-style-type: none">sq1 := new(Square)</li>
<li style="list-style-type: none">sq1.side = 5</li>
<li style="list-style-type: none">areaIntf := sq1</li>
<li style="list-style-type: none">fmt.Printf("area: %f\n", areaIntf.Area())</li>
</ul>
}<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
</body></html>